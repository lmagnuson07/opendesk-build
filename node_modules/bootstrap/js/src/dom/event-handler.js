/**
 * --------------------------------------------------------------------------
<<<<<<< HEAD
 * Bootstrap (v5.1.3): dom/event-handler.js
=======
 * Bootstrap (v5.2.0-beta1): dom/event-handler.js
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

import { getjQuery } from '../util/index'

/**
<<<<<<< HEAD
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
=======
 * Constants
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
 */

const namespaceRegex = /[^.]*(?=\..*)\.|.*/
const stripNameRegex = /\..*/
const stripUidRegex = /::\d+$/
const eventRegistry = {} // Events storage
let uidEvent = 1
const customEvents = {
  mouseenter: 'mouseover',
  mouseleave: 'mouseout'
}
<<<<<<< HEAD
const customEventsRegex = /^(mouseenter|mouseleave)/i
=======

>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
const nativeEvents = new Set([
  'click',
  'dblclick',
  'mouseup',
  'mousedown',
  'contextmenu',
  'mousewheel',
  'DOMMouseScroll',
  'mouseover',
  'mouseout',
  'mousemove',
  'selectstart',
  'selectend',
  'keydown',
  'keypress',
  'keyup',
  'orientationchange',
  'touchstart',
  'touchmove',
  'touchend',
  'touchcancel',
  'pointerdown',
  'pointermove',
  'pointerup',
  'pointerleave',
  'pointercancel',
  'gesturestart',
  'gesturechange',
  'gestureend',
  'focus',
  'blur',
  'change',
  'reset',
  'select',
  'submit',
  'focusin',
  'focusout',
  'load',
  'unload',
  'beforeunload',
  'resize',
  'move',
  'DOMContentLoaded',
  'readystatechange',
  'error',
  'abort',
  'scroll'
])

/**
<<<<<<< HEAD
 * ------------------------------------------------------------------------
 * Private methods
 * ------------------------------------------------------------------------
=======
 * Private methods
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
 */

function getUidEvent(element, uid) {
  return (uid && `${uid}::${uidEvent++}`) || element.uidEvent || uidEvent++
}

function getEvent(element) {
  const uid = getUidEvent(element)

  element.uidEvent = uid
  eventRegistry[uid] = eventRegistry[uid] || {}

  return eventRegistry[uid]
}

function bootstrapHandler(element, fn) {
  return function handler(event) {
    event.delegateTarget = element

    if (handler.oneOff) {
      EventHandler.off(element, event.type, fn)
    }

    return fn.apply(element, [event])
  }
}

function bootstrapDelegationHandler(element, selector, fn) {
  return function handler(event) {
    const domElements = element.querySelectorAll(selector)

    for (let { target } = event; target && target !== this; target = target.parentNode) {
<<<<<<< HEAD
      for (let i = domElements.length; i--;) {
        if (domElements[i] === target) {
          event.delegateTarget = target

          if (handler.oneOff) {
            EventHandler.off(element, event.type, selector, fn)
          }

          return fn.apply(target, [event])
        }
      }
    }

    // To please ESLint
    return null
=======
      for (const domElement of domElements) {
        if (domElement !== target) {
          continue
        }

        event.delegateTarget = target

        if (handler.oneOff) {
          EventHandler.off(element, event.type, selector, fn)
        }

        return fn.apply(target, [event])
      }
    }
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
  }
}

function findHandler(events, handler, delegationSelector = null) {
<<<<<<< HEAD
  const uidEventList = Object.keys(events)

  for (let i = 0, len = uidEventList.length; i < len; i++) {
    const event = events[uidEventList[i]]

    if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {
      return event
    }
  }

  return null
}

function normalizeParams(originalTypeEvent, handler, delegationFn) {
  const delegation = typeof handler === 'string'
  const originalHandler = delegation ? delegationFn : handler

  let typeEvent = getTypeEvent(originalTypeEvent)
  const isNative = nativeEvents.has(typeEvent)

  if (!isNative) {
=======
  return Object.values(events)
    .find(event => event.originalHandler === handler && event.delegationSelector === delegationSelector)
}

function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
  const delegation = typeof handler === 'string'
  const originalHandler = delegation ? delegationFunction : handler
  let typeEvent = getTypeEvent(originalTypeEvent)

  if (!nativeEvents.has(typeEvent)) {
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
    typeEvent = originalTypeEvent
  }

  return [delegation, originalHandler, typeEvent]
}

<<<<<<< HEAD
function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {
=======
function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
  if (typeof originalTypeEvent !== 'string' || !element) {
    return
  }

  if (!handler) {
<<<<<<< HEAD
    handler = delegationFn
    delegationFn = null
=======
    handler = delegationFunction
    delegationFunction = null
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
  }

  // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
  // this prevents the handler from being dispatched the same way as mouseover or mouseout does
<<<<<<< HEAD
  if (customEventsRegex.test(originalTypeEvent)) {
    const wrapFn = fn => {
=======
  if (originalTypeEvent in customEvents) {
    const wrapFunction = fn => {
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
      return function (event) {
        if (!event.relatedTarget || (event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget))) {
          return fn.call(this, event)
        }
      }
    }

<<<<<<< HEAD
    if (delegationFn) {
      delegationFn = wrapFn(delegationFn)
    } else {
      handler = wrapFn(handler)
    }
  }

  const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn)
  const events = getEvent(element)
  const handlers = events[typeEvent] || (events[typeEvent] = {})
  const previousFn = findHandler(handlers, originalHandler, delegation ? handler : null)

  if (previousFn) {
    previousFn.oneOff = previousFn.oneOff && oneOff
=======
    if (delegationFunction) {
      delegationFunction = wrapFunction(delegationFunction)
    } else {
      handler = wrapFunction(handler)
    }
  }

  const [delegation, originalHandler, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction)
  const events = getEvent(element)
  const handlers = events[typeEvent] || (events[typeEvent] = {})
  const previousFunction = findHandler(handlers, originalHandler, delegation ? handler : null)

  if (previousFunction) {
    previousFunction.oneOff = previousFunction.oneOff && oneOff
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4

    return
  }

  const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ''))
  const fn = delegation ?
<<<<<<< HEAD
    bootstrapDelegationHandler(element, handler, delegationFn) :
=======
    bootstrapDelegationHandler(element, handler, delegationFunction) :
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
    bootstrapHandler(element, handler)

  fn.delegationSelector = delegation ? handler : null
  fn.originalHandler = originalHandler
  fn.oneOff = oneOff
  fn.uidEvent = uid
  handlers[uid] = fn

  element.addEventListener(typeEvent, fn, delegation)
}

function removeHandler(element, events, typeEvent, handler, delegationSelector) {
  const fn = findHandler(events[typeEvent], handler, delegationSelector)

  if (!fn) {
    return
  }

  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector))
  delete events[typeEvent][fn.uidEvent]
}

function removeNamespacedHandlers(element, events, typeEvent, namespace) {
  const storeElementEvent = events[typeEvent] || {}

<<<<<<< HEAD
  Object.keys(storeElementEvent).forEach(handlerKey => {
    if (handlerKey.includes(namespace)) {
      const event = storeElementEvent[handlerKey]

      removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector)
    }
  })
=======
  for (const handlerKey of Object.keys(storeElementEvent)) {
    if (handlerKey.includes(namespace)) {
      const event = storeElementEvent[handlerKey]
      removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector)
    }
  }
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
}

function getTypeEvent(event) {
  // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
  event = event.replace(stripNameRegex, '')
  return customEvents[event] || event
}

const EventHandler = {
<<<<<<< HEAD
  on(element, event, handler, delegationFn) {
    addHandler(element, event, handler, delegationFn, false)
  },

  one(element, event, handler, delegationFn) {
    addHandler(element, event, handler, delegationFn, true)
  },

  off(element, originalTypeEvent, handler, delegationFn) {
=======
  on(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, false)
  },

  one(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, true)
  },

  off(element, originalTypeEvent, handler, delegationFunction) {
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
    if (typeof originalTypeEvent !== 'string' || !element) {
      return
    }

<<<<<<< HEAD
    const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn)
=======
    const [delegation, originalHandler, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction)
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
    const inNamespace = typeEvent !== originalTypeEvent
    const events = getEvent(element)
    const isNamespace = originalTypeEvent.startsWith('.')

    if (typeof originalHandler !== 'undefined') {
      // Simplest case: handler is passed, remove that listener ONLY.
      if (!events || !events[typeEvent]) {
        return
      }

      removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null)
      return
    }

    if (isNamespace) {
<<<<<<< HEAD
      Object.keys(events).forEach(elementEvent => {
        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1))
      })
    }

    const storeElementEvent = events[typeEvent] || {}
    Object.keys(storeElementEvent).forEach(keyHandlers => {
=======
      for (const elementEvent of Object.keys(events)) {
        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1))
      }
    }

    const storeElementEvent = events[typeEvent] || {}
    for (const keyHandlers of Object.keys(storeElementEvent)) {
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
      const handlerKey = keyHandlers.replace(stripUidRegex, '')

      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        const event = storeElementEvent[keyHandlers]
<<<<<<< HEAD

        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector)
      }
    })
=======
        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector)
      }
    }
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
  },

  trigger(element, event, args) {
    if (typeof event !== 'string' || !element) {
      return null
    }

    const $ = getjQuery()
    const typeEvent = getTypeEvent(event)
    const inNamespace = event !== typeEvent
<<<<<<< HEAD
    const isNative = nativeEvents.has(typeEvent)

    let jQueryEvent
    let bubbles = true
    let nativeDispatch = true
    let defaultPrevented = false
    let evt = null
=======

    let jQueryEvent = null
    let bubbles = true
    let nativeDispatch = true
    let defaultPrevented = false
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4

    if (inNamespace && $) {
      jQueryEvent = $.Event(event, args)

      $(element).trigger(jQueryEvent)
      bubbles = !jQueryEvent.isPropagationStopped()
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped()
      defaultPrevented = jQueryEvent.isDefaultPrevented()
    }

<<<<<<< HEAD
    if (isNative) {
      evt = document.createEvent('HTMLEvents')
      evt.initEvent(typeEvent, bubbles, true)
    } else {
      evt = new CustomEvent(event, {
        bubbles,
        cancelable: true
      })
    }

    // merge custom information in our event
    if (typeof args !== 'undefined') {
      Object.keys(args).forEach(key => {
=======
    const evt = new Event(event, { bubbles, cancelable: true })

    // merge custom information in our event
    if (typeof args !== 'undefined') {
      for (const key of Object.keys(args)) {
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
        Object.defineProperty(evt, key, {
          get() {
            return args[key]
          }
        })
<<<<<<< HEAD
      })
=======
      }
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
    }

    if (defaultPrevented) {
      evt.preventDefault()
    }

    if (nativeDispatch) {
      element.dispatchEvent(evt)
    }

<<<<<<< HEAD
    if (evt.defaultPrevented && typeof jQueryEvent !== 'undefined') {
=======
    if (evt.defaultPrevented && jQueryEvent) {
>>>>>>> 25720be54b4b3911b96b878f3e79e36853fd54b4
      jQueryEvent.preventDefault()
    }

    return evt
  }
}

export default EventHandler
